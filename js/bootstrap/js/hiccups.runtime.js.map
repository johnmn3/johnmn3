{"version":3,"file":"hiccups.runtime.js","sources":["hiccups/runtime.cljs"],"mappings":"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","names":["class","clojure.string/replace","tag","hiccups.runtime/character-escapes","hiccups.runtime/*html-mode*","p__9392","vec__9400","seq__9401","cljs.core/seq","first__9402","cljs.core/first","cljs.core/next","hiccups.runtime/normalize-element","content","f","tag-attrs","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/str","x","hiccups.runtime/render-html","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.core/seq?","hiccups.runtime/xml-mode?","hiccups.runtime/re-tag","or__3949__auto__","hiccups.runtime/container-tags","hiccups.runtime/render-attr-map","attrs","hiccups.runtime/as-str","name","element","text","hiccups.runtime/xml-attribute","value","cljs.core.sort.cljs$core$IFn$_invoke$arity$1","hiccups.runtime/render-attribute","clojure.string/escape","hiccups.runtime/escape-html","p__9339","vec__9344","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","cljs.core/Symbol","cljs.core/Keyword","id","hiccups.runtime/in-mode","mode","cljs.core/name","map-attrs","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","hiccups.runtime/h","vec__9452","cljs.core.merge.cljs$core$IFn$_invoke$arity$variadic","*html-mode*9310","hiccups.runtime/end-tag","cljs.core/vector?","hiccups.runtime/render-element","cljs.core/map?","vec__9412","_","cljs.core/re-matches","cljs.core/not"],"sourcesContent":["(ns hiccups.runtime\n  (:require [clojure.string :as cstring]))\n\n(def ^{:doc \"Regular expression that parses a CSS-style id and class from a tag name.\" :private true}\n  re-tag #\"([^\\s\\.#]+)(?:#([^\\s\\.#]+))?(?:\\.([^\\s#]+))?\")\n\n(def ^{:doc \"Characters to replace when escaping HTML\" :private true}\n  character-escapes {\\& \"&amp;\", \\< \"&lt;\", \\> \"&gt;\", \\\" \"&quot;\"})\n\n(def ^{:doc \"A list of tags that need an explicit ending tag when rendered.\"}\n  container-tags\n  #{\"a\" \"b\" \"body\" \"canvas\" \"dd\" \"div\" \"dl\" \"dt\" \"em\" \"fieldset\" \"form\" \"h1\" \"h2\" \"h3\"\n    \"h4\" \"h5\" \"h6\" \"head\" \"html\" \"i\" \"iframe\" \"label\" \"li\" \"ol\" \"option\" \"pre\"\n    \"script\" \"span\" \"strong\" \"style\" \"table\" \"textarea\" \"ul\"})\n\n(defn as-str [x]\n  (if (or (keyword? x) (symbol? x))\n    (name x)\n    (str x)))\n\n(def ^:dynamic *html-mode* :xml)\n\n(defn- xml-mode? []\n  (= *html-mode* :xml))\n\n(defn in-mode [mode f]\n  (binding [*html-mode* mode]\n    (f)))\n\n(defn escape-html\n  \"Change special characters into HTML character entities.\"\n  [text]\n  (-> (as-str text)\n      (cstring/escape character-escapes)))\n\n(def h escape-html) ; alias for escape-html\n\n(defn end-tag []\n  (if (xml-mode?) \" />\" \">\"))\n\n(defn xml-attribute [name value]\n  (str \" \" (as-str name) \"=\\\"\" (escape-html value) \"\\\"\"))\n\n(defn render-attribute [[name value]]\n  (cond\n    (true? value)\n      (if (xml-mode?)\n          (xml-attribute name name)\n          (str \" \" (as-str name)))\n    (not value)\n      \"\"\n    :else\n      (xml-attribute name value)))\n\n(defn render-attr-map [attrs]\n  (apply str\n    (sort (map render-attribute attrs))))\n\n(defn normalize-element\n  \"Ensure a tag vector is of the form [tag-name attrs content].\"\n  [[tag & content]]\n  (when (not (or (keyword? tag) (symbol? tag) (string? tag)))\n    (throw (str tag \" is not a valid tag name\")))\n  (let [[_ tag id class] (re-matches re-tag (as-str tag))\n        tag-attrs        {:id id\n                          :class (if class (cstring/replace class \".\" \" \"))}\n        map-attrs        (first content)]\n    (if (map? map-attrs)\n      [tag (merge tag-attrs map-attrs) (next content)]\n      [tag tag-attrs content])))\n\n(declare render-html)\n\n(defn render-element\n  \"Render a tag vector as a HTML element.\"\n  [element]\n  (let [[tag attrs content] (normalize-element element)]\n    (if (or content (container-tags tag))\n      (str \"<\" tag (render-attr-map attrs) \">\"\n           (render-html content)\n           \"</\" tag \">\")\n      (str \"<\" tag (render-attr-map attrs) (end-tag)))))\n\n(defn render-html\n  \"Turn a Clojure data type into a string of HTML.\"\n  [x]\n  (cond\n    (vector? x) (render-element x)\n    (seq? x) (apply str (map render-html x))\n    :else (as-str x)))\n"]}