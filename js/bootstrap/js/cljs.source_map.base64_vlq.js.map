{"version":3,"file":"cljs.source_map.base64_vlq.js","sources":["cljs/source_map/base64_vlq.cljs"],"mappings":";;;;;AAaA,4CAAA,5CAAac;AACb,AAAaG,sCAAS,CAAA,OAAkBH,AAAA;AACxC,AAAaE,2CAAc,uCAAA,tCAAKC;AAChC,AAAaO,kDAAqBP;AAElC,2CAAA,3CAAMI,8FAAelB;AACnB,GAAI,KAAA,JAAMA,JADZ;AAEI,yBAAA,jBAAK,UAAA,TAAgB,GAAGA;;AACxB,qBAAA,bAAG,MAAA,LAAgBA;;;AAEvB,6CAAA,7CAAMK,kGAAiBL;AACrB,IAAMO,aAAK,uDAAA,vDAACC,6CAAE,KAAA,JAASR,/DADzB;IAEQM,UAAQ,MAAA,LAAiBN;AAD/B,AAEE,GAAIO;AACF,UAAGD;;AACHA;;;AAEN,wCAAA,xCAAMoB,wFAAYP;AAChB,IAAMH,KAAG,KAAAC,dADX;IAEQP,MAAI,AAACQ,yCAAcC;AADzB,AAEE,IAAOV,cAAM,CAASC,MAAIG;IACnBH,gBAAM,CAA2BA,QAAIC,AAAA;;AAD5C,AAEE,GAAI,iBAAA,hBAAMD;AACR,IAAMD,kBAAM,CAAQA,cAAMY;AAA1B,AACE,AAASL,UAAG,AAACI,8BAAcX;;AAC3B,eAAO,CAASC,gBAAIG;eACb,CAA2BH,kBAAIC,AAAA;;;;;AACxC,AAASK,UAAG,AAACI,8BAAcX;;;;;AAC/B,oDAAKO;;AAET,oCAAA,pCAAMM,gFAAQtB;AAAd,AACE,OAACuB,8CAAMC,cAAI,AAACC,4CAAIC,sCAAW1B;;AAE7B,oCAAA,pCAAMY,gFAAQd;AAAd,AACE,IAAM8B,IAAE,AAAU9B;AAChB,QAAA,JAAOG,JADT;aACE,TAAWC;YAAX,RAAoBC;;AAApB,AACE,GAAM,CAAIF,KAAE2B;AACV,MAAO,KAAAb,MAAA,jBADT;;AAAA;;AAEA,IAAMN,QAAM,AAACkB,8BAAc,AAAS7B,SAAEG;AAAtC,AACE,IAAMA,QAAE,KAAA,JAAKA;IACP4B,sBAAc,6DAAA,5DAAM,CAASpB,QAAMY;IACnCZ,YAAM,CAASA,QAAMI;IACrBX,aAAO,CAAGA,SAAO,CAAgBO,aAAMN;IACvCA,YAAM,CAAGA,QAAMQ,AAAA;AACnB,GAAIkB,HALN;AAMI,eAAO5B;eAAEC;eAAOC;;;;;;AAChB,YAAAJ,kBAAA,KAAA;;AAAA,AACC,OAACK,eAAK,AAACC,2CAAgBH,YACjB,iBAAMJ,QAAE,AAAYA,YAAEG;AACpB,GAAU,AAACJ,4BAAcC,/BAD3B;AACE;;AAAA,AACE,QAACc,kEAAAA,yEAAAA,TAAOd,qDAAAA;;;;CAJnB,KAAA;;;;;AAMZ","names":["clojure.string/blank?","s","cljs.core/LazySeq","v","i","result","shift","cljs.core/cons","cljs.source-map.base64-vlq/from-vlq-signed","shifted","neg?","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","digit","vlq","cljs.source-map.base64-vlq/vlq-base-shift","cljs.source-map.base64-vlq/decode","cljs.source-map.base64-vlq/vlq-base-mask","cljs.source-map.base64-vlq/vlq-base","js/Error","sb","goog/string.StringBuffer","cljs.source-map.base64-vlq/to-vlq-signed","n","cljs.source-map.base64/encode","cljs.source-map.base64-vlq/vlq-continuation-bit","cljs.source-map.base64-vlq/encode","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/str","cljs.core.map.cljs$core$IFn$_invoke$arity$2","cljs.source-map.base64-vlq/encode-val","cljs.source-map.base64/decode","l","continuation?"],"sourcesContent":[";   Copyright (c) Rich Hickey. All rights reserved.\n;   The use and distribution terms for this software are covered by the\n;   Eclipse Public License 1.0 (http://opensource.org/licenses/eclipse-1.0.php)\n;   which can be found in the file epl-v10.html at the root of this distribution.\n;   By using this software in any fashion, you are agreeing to be bound by\n;   the terms of this license.\n;   You must not remove this notice, or any other, from this software.\n\n(ns cljs.source-map.base64-vlq\n  (:require [clojure.string :as string]\n            [cljs.source-map.base64 :as base64])\n  (:import [goog.string StringBuffer]))\n\n(def ^:const vlq-base-shift 5)\n(def ^:const vlq-base (bit-shift-left 1 vlq-base-shift))\n(def ^:const vlq-base-mask (dec vlq-base))\n(def ^:const vlq-continuation-bit vlq-base)\n\n(defn to-vlq-signed [v]\n  (if (neg? v)\n    (inc (bit-shift-left (- v) 1))\n    (+ (bit-shift-left v 1) 0)))\n\n(defn from-vlq-signed [v]\n  (let [neg? (= (bit-and v 1) 1)\n        shifted (bit-shift-right v 1)]\n    (if neg?\n      (- shifted)\n      shifted)))\n\n(defn encode-val [n]\n  (let [sb (StringBuffer.)\n        vlq (to-vlq-signed n)]\n    (loop [digit (bit-and vlq vlq-base-mask)\n           vlq   (bit-shift-right-zero-fill vlq vlq-base-shift)]\n      (if (pos? vlq)\n        (let [digit (bit-or digit vlq-continuation-bit)]\n          (.append sb (base64/encode digit))\n          (recur (bit-and vlq vlq-base-mask)\n                 (bit-shift-right-zero-fill vlq vlq-base-shift)))\n        (.append sb (base64/encode digit))))\n    (str sb)))\n\n(defn encode [v]\n  (apply str (map encode-val v)))\n\n(defn decode [s]\n  (let [l (.-length s)]\n    (loop [i 0 result 0 shift 0]\n      (when (>= i l)\n        (throw (js/Error. \"Expected more digits in base 64 VLQ value.\")))\n      (let [digit (base64/decode (.charAt s i))]\n        (let [i (inc i)\n              continuation? (pos? (bit-and digit vlq-continuation-bit))\n              digit (bit-and digit vlq-base-mask)\n              result (+ result (bit-shift-left digit shift))\n              shift (+ shift vlq-base-shift)]\n          (if continuation?\n            (recur i result shift)\n            (lazy-seq\n             (cons (from-vlq-signed result)\n                   (let [s (.substring s i)]\n                     (when-not (string/blank? s)\n                       (decode s)))))))))))\n\n(comment\n  ;; tests\n\n  (bit-shift-right-zero-fill 127 1) ;; 63\n  (bit-shift-right-zero-fill -127 1) ;; 2147483584\n  \n  (to-vlq-signed 32) ;; 64\n  (to-vlq-signed -32) ;; 65\n  (from-vlq-signed 64) ;; 32\n  (from-vlq-signed 65) ;; -32\n\n  ;; Base64 VLQ can only represent 32bit values\n\n  (encode-val 32) ; \"gC\"\n  (decode \"gC\") ; {:value 32 :rest \"\"}\n\n  (decode \"AAgBC\") ; (0 0 16 1)\n  \n  ;; lines kept count by semicolons, segments delimited by commas\n  ;; the above is gline 0, gcol 0, file 0, line 16, col 1, no name if this was the first segment read\n\n  (decode \"AAggBC\") ; very clever way to encode large values\n  (decode \"AAggBCA\") ; 5 values instead of 4\n\n  (encode [0 0 16 1]) ; \"AAgBC\"\n\n  (decode \"IAWdD\") ; (4 0 11 -14 -1) this is correct\n  ;; gline N, gcol +4, file +0, line +11, col -14, name -1\n\n  ;; Notes about format\n  ;; we always have 1, 4, or 5 values, all zero-based indexes\n  ;; 1. generated col - relative - reset on every new line in generated source\n  ;; 2. index into sources list - relative\n  ;; 3. original line - relative\n  ;; 4. origin column - relative\n  ;; 5. name - relative\n  )\n"]}