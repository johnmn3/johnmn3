["^ ","~:rename-macros",null,"~:renames",["^ "],"~:meta",["^ ","~:file","cells/cell$macros.cljc","~:line",1,"~:column",5,"~:end-line",1,"~:end-column",15],"~:use-macros",null,"~:excludes",["~#set",[]],"~:name","~$cells.cell$macros","~:imports",null,"~:requires",["^ ","~$cells.util","^?","~$util","^?","~$cljs.core","^A","~$goog","^B"],"~:seen",["^:",["~:require"]],"~:shadow/js-access-global",["^:",["Error"]],"~:uses",null,"~:defs",["^ ","~$lib-bindings",["^ ","^;","~$cells.cell$macros/lib-bindings","^3","cells/cell$macros.cljc","^4",4,"^5",1,"^6",4,"^7",18,"^2",["^ ","^3","cells/cell$macros.cljc","^4",4,"^5",6,"^6",4,"^7",18],"~:tag","~$any"],"~$defcell",["^ ","~:protocol-inline",null,"^2",["^ ","^3","cells/cell$macros.cljc","^7",18,"~:top-fn",["^ ","~:variadic",true,"~:max-fixed-arity",3,"~:method-params",[["~#list",["~$&form","~$&env","~$the-name","~$body"]]],"~:arglists",["^R",[["^S","^T","^U","~$&","^V"]]],"~:arglists-meta",["^R",[null]]],"^5",11,"^4",12,"~:macro",true,"^6",12,"^W",["^R",["~$quote",["^R",[["^U","~$&","^V"]]]]],"~:doc","Defines a named cell."],"^;","~$cells.cell$macros/defcell","^O",true,"^3","cells/cell$macros.cljc","^7",18,"^N",["^ ","^O",true,"^P",3,"^Q",[["^R",["^S","^T","^U","^V"]]],"^W",["^R",[["^S","^T","^U","~$&","^V"]]],"^X",["^R",[null]]],"^Q",[["^R",["^S","^T","^U","^V"]]],"~:protocol-impl",null,"^X",["^R",[null]],"^5",1,"^4",12,"^Y",true,"^6",12,"^P",3,"~:fn-var",false,"^W",["^R",[["^S","^T","^U","~$&","^V"]]],"^[","Defines a named cell."],"~$cell-name",["^ ","^M",null,"^2",["^ ","^3","cells/cell$macros.cljc","^4",24,"^5",8,"^6",24,"^7",17,"~:private",true,"^W",["^R",["^Z",["^R",[["~$key"]]]]],"^[","Construct a cell-name, incorporating the runtime-value of `key` if provided."],"^14",true,"^;","~$cells.cell$macros/cell-name","^O",false,"^3","cells/cell$macros.cljc","^7",17,"^Q",["^R",[["^15"]]],"^11",null,"^X",["^R",[null,null]],"^5",1,"^4",24,"^6",24,"^P",1,"^12",true,"^W",["^R",["^Z",["^R",[["^15"]]]]],"^[","Construct a cell-name, incorporating the runtime-value of `key` if provided."],"~$cell",["^ ","^M",null,"^2",["^ ","^3","cells/cell$macros.cljc","^7",15,"^N",["^ ","^O",false,"^P",4,"^Q",["^R",[["^S","^T","~$expr"],["^S","^T","^15","^18"]]],"^W",["^R",[["^S","^T","^18"],["^S","^T","^15","^18"]]],"^X",["^R",[null,null]]],"^5",11,"^4",32,"^Y",true,"^6",32,"^W",["^R",["^Z",["^R",[["^18"],["^15","^18"]]]]],"^[","Returns an anonymous cell. Only one cell will be returned per lexical instance of `cell`,\n  unless a unique `key` is provided. Helper functions in `lib-bindings` (eg. interval) are\n  hoisted into scope, as is `self`, which refers to the current cell."],"^;","~$cells.cell$macros/cell","^O",false,"^3","cells/cell$macros.cljc","^7",15,"^N",["^ ","^O",false,"^P",4,"^Q",["^R",[["^S","^T","^18"],["^S","^T","^15","^18"]]],"^W",["^R",[["^S","^T","^18"],["^S","^T","^15","^18"]]],"^X",["^R",[null,null]]],"^Q",["^R",[["^S","^T","^18"],["^S","^T","^15","^18"]]],"^11",null,"^X",["^R",[null,null]],"^5",1,"^4",32,"^Y",true,"^6",32,"^P",4,"^12",false,"^W",["^R",[["^S","^T","^18"],["^S","^T","^15","^18"]]],"^[","Returns an anonymous cell. Only one cell will be returned per lexical instance of `cell`,\n  unless a unique `key` is provided. Helper functions in `lib-bindings` (eg. interval) are\n  hoisted into scope, as is `self`, which refers to the current cell."],"~$cell-fn",["^ ","^M",null,"^2",["^ ","^3","cells/cell$macros.cljc","^7",18,"^N",["^ ","^O",true,"^P",2,"^Q",[["^R",["^S","^T","^V"]]],"^W",["^R",[["^S","^T","~$&","^V"]]],"^X",["^R",[null]]],"^5",11,"^4",42,"^Y",true,"^6",42,"^W",["^R",["^Z",["^R",[["~$&","^V"]]]]],"^[","Returns an anonymous function which will evaluate with the current cell in the stack.\n  Similar to Clojure's `bound-fn`, but only cares about the currently bound cell."],"^;","~$cells.cell$macros/cell-fn","^O",true,"^3","cells/cell$macros.cljc","^7",18,"^N",["^ ","^O",true,"^P",2,"^Q",[["^R",["^S","^T","^V"]]],"^W",["^R",[["^S","^T","~$&","^V"]]],"^X",["^R",[null]]],"^Q",[["^R",["^S","^T","^V"]]],"^11",null,"^X",["^R",[null]],"^5",1,"^4",42,"^Y",true,"^6",42,"^P",2,"^12",false,"^W",["^R",[["^S","^T","~$&","^V"]]],"^[","Returns an anonymous function which will evaluate with the current cell in the stack.\n  Similar to Clojure's `bound-fn`, but only cares about the currently bound cell."]],"~:require-macros",["^ ","^A","^A"],"~:cljs.analyzer/constants",["^ ","^C",["^:",["~$&","~$context__18550__auto__","~$cells.cell/cell*","~$try","~$clojure.core/let","~$args__18551__auto__","~$cells.cell/*eval-context*","~$cells.cell/cell","~$self","~$clojure.core/fn","~$the-cell__18549__auto__","~$cells.eval-context/handle-error","~$cells.lib/timeout","~$clojure.core/first","~$cells.lib/fetch","~$clojure.core/cons","~$clojure.core/hash","~$clojure.core/binding","~$cells.cell/*cell-stack*","~$clojure.core/keyword","~$clojure.core/str","~$clojure.core/apply","~$cells.lib/interval","~$catch","~$error__18552__auto__","~$js/Error","~$def"]],"~:order",["^1S","^1I","^1K","^1W","^1A","^1?","^1F","^1E","^1P","^1Q","^1M","^1D","^1G","^1J","^1O","^1>","^1C","~$&","^1B","^1N","^1L","^1@","^1R","^1T","^1V","^1U","^1H"]],"~:flags",["^ ","^D",["^:",[]]],"~:js-deps",["^ "],"~:deps",["^B","^A","^?"]]