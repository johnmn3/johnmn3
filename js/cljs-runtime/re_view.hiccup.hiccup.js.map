{"version":3,"file":"re_view.hiccup.hiccup.js","sources":["re_view/hiccup/hiccup.cljs"],"mappings":"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","names":["re-view.hiccup.hiccup/parse-key","x","cljs.core/re-find","p1__32965#","cljs.core.update.cljs$core$IFn$_invoke$arity$3","cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2","clojure.string/replace","p1__32966#","cljs.core.subs.cljs$core$IFn$_invoke$arity$2","re-view.hiccup.hiccup/parse-key-memoized","cljs.core/memoize","re-view.hiccup.hiccup/reduce-flatten-seqs","f","init","coll","cljs.core.reduce.cljs$core$IFn$_invoke$arity$3","c","cljs.core/seq?","cljs.core.conj.cljs$core$IFn$_invoke$arity$2","re-view.hiccup.hiccup/parse-args","form","len","cljs.core/count","first-child","cljs.core/PersistentArrayMap","cljs.core/PersistentHashMap","cljs.core.subvec.cljs$core$IFn$_invoke$arity$3","re-view.hiccup.hiccup/camelCase","s","p__32998","vec__32999","cljs.core.nth.cljs$core$IFn$_invoke$arity$3","_","clojure.string/upper-case","re-view.hiccup.hiccup/camelCase?","attr-name","cljs.core/not","re-view.hiccup.hiccup/key->react-attr","k","cljs.core/keyword-identical?","k-str","cljs.core/name","G__33014","re-view.hiccup.hiccup/map->js","style","style-js","seq__33018","cljs.core/seq","chunk__33019","count__33020","i__33021","vec__33022","temp__5457__auto__","cljs.core/chunked-seq?","c__4351__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","vec__33031","cljs.core/first","cljs.core/next","v","re-view.hiccup.hiccup/concat-classes","k-classes","class","classes","G__33087","cljs.core.into.cljs$core$IFn$_invoke$arity$2","clojure.string.join.cljs$core$IFn$_invoke$arity$2","re-view.hiccup.hiccup/*wrap-props*","re-view.hiccup.hiccup/props->js","tag","k-id","props","or__3949__auto__","map__33109","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply.cljs$core$IFn$_invoke$arity$2","cljs.core/hash-map","cljs.core.get.cljs$core$IFn$_invoke$arity$2","class-name","G__33110","cljs.core/boolean","prop-js","G__33116","G__33119","G__33124","seq__33125","chunk__33126","count__33127","i__33128","vec__33129","vec__33133","re-view.hiccup.hiccup/*create-element*","js/module$node_modules$react$index.createElement"],"sourcesContent":["(ns re-view.hiccup.hiccup\n  (:require [clojure.string :as string]\n            [\"react\" :as react]))\n\n(defn parse-key\n  \"Parses a hiccup key like :div#id.class1.class2 to return the tag name, id, and classes.\n   If tag-name is ommitted, defaults to 'div'. Class names are padded with spaces.\"\n  [x]\n  (-> (re-find #\":([^#.]*)(?:#([^.]+))?(.*)?\" (str x))\n      (update 1 #(if (= \"\" %) \"div\" (string/replace % \"/\" \":\")))\n      (update 3 #(when %\n                   (string/replace (subs % 1) \".\" \" \")))))\n\n;; parse-key is an ideal target for memoization, because keyword forms are\n;; frequently reused (eg. in lists) and almost never generated dynamically.\n(def parse-key-memoized (memoize parse-key))\n\n(defn reduce-flatten-seqs\n  \"Recursively apply f to nested vectors, unwrapping seqs. Similar to recursive `mapcat` but returns a vector.\"\n  [f init coll]\n  (reduce (fn my-f [c x]\n            (if (seq? x)\n              (reduce-flatten-seqs f c x)\n              (conj c (f x)))) init coll))\n\n(defn parse-args\n  \"Return props and children for a hiccup form. If the second element is not a map, supplies an empty map as props.\"\n  [form]\n  (let [len (count form)]\n    (cond (= len 1) [{} []]\n          (let [first-child (form 1)]\n            (or (nil? first-child)\n                (instance? PersistentArrayMap first-child)\n                (instance? PersistentHashMap first-child))) [(form 1) (if (> len 2) (subvec form 2 len) [])]\n          :else [{} (subvec form 1 len)])))\n\n(defn ^string camelCase [s]\n  (string/replace s #\"-([a-z])\" (fn [[_ s]] (string/upper-case s))))\n\n(defn ^boolean camelCase?\n  \"CamelCase by default, only exceptions are data- and aria- attributes.\"\n  [attr-name]\n  (not (re-find #\"^(?:data\\-|aria\\-)\" attr-name)))\n\n(defn key->react-attr\n  \"CamelCase react keys, except for aria- and data- attributes\"\n  [k]\n  (if (keyword-identical? k :for)\n    \"htmlFor\"\n    (let [k-str (name k)]\n      (cond-> k-str\n              (camelCase? k-str) (camelCase)))))\n\n(defn map->js\n  \"Return javascript object with camelCase keys. Not recursive.\"\n  [style]\n  (let [style-js (js-obj)]\n    (doseq [[k v] style]\n      (aset style-js (camelCase (name k)) v))\n    style-js))\n\n(defn concat-classes\n  \"Build className from keyword classes, :class and :classes.\"\n  [^js/String k-classes ^js/String class classes]\n  (->> (cond-> []\n               k-classes (conj k-classes)\n               class (conj class)\n               classes (into classes))\n       (string/join \" \")))\n\n(def ^:dynamic *wrap-props* nil)\n\n(defn props->js\n  \"Returns a React-conformant javascript object. An alternative to clj->js,\n  allowing for key renaming without an extra loop through every prop map.\"\n  [tag k-id k-classes props]\n  (when (or props k-id k-classes)\n    (let [{:keys [class class-name classes] :as props} (cond-> props\n                                                               (boolean *wrap-props*)\n                                                               (*wrap-props* tag))\n          prop-js (cond-> (js-obj)\n                          k-id (doto (aset \"id\" k-id))\n                          (or k-classes class class-name classes) (doto (aset \"className\" (concat-classes k-classes (or class class-name) classes))))]\n      (doseq [[k v] props]\n        (cond\n          ;; convert :style and :dangerouslySetInnerHTML to js objects\n          (or (keyword-identical? k :style)\n              (keyword-identical? k :dangerouslySetInnerHTML))\n          (aset prop-js (name k) (map->js v))\n          ;; ignore className-related keys\n          (or (keyword-identical? k :classes)\n              (keyword-identical? k :class)) nil\n          ;; passthrough all other values\n          :else (aset prop-js (key->react-attr k) v)))\n      prop-js)))\n\n\n(def ^:dynamic *create-element* react/createElement)"]}